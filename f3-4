---
# Purpose: Repurpose hosts by wiping only "data" volumes (mounted under /data*)
# Param: WIPE = REPORT (default) -> dry run email; WIPE = WIPE -> execute
# Safety: Never affects root VG or the device backing "/"
# Email: Sends report to <submitter>@citi.com (submitter auto-detected)

- name: Data VG cleanup (REPORT/ WIPE)
  hosts: all
  become: true
  gather_facts: true

  vars:
    # Portal passes WIPE as an extra var; default to REPORT (non-empty to satisfy portal)
    WIPE: "{{ WIPE | default('REPORT') }}"
    data_mount_regex: '^/data($|/)'
    report_path: "/tmp/datavg_cleanup_report_{{ inventory_hostname }}.txt"

    # Try common CI/portal env vars, then sudo user, then current user
    submitting_user: >-
      {{ lookup('env','STATFLEET_USER')
         or lookup('env','BUILD_USER')
         or lookup('env','SUDO_USER')
         or ansible_env.USER
         or ansible_user_id
         or 'unknown' }}
    submitter_email: "{{ submitting_user }}@citi.com"

  pre_tasks:
    - name: Sanity | must run as root
      assert:
        that: ansible_user_id == 'root'
        fail_msg: "Run with become: true"

    - name: Detect root device
      command: findmnt -no SOURCE /
      register: root_src
      changed_when: false

    - name: Parse root VG name (if LVM)
      set_fact:
        root_vg: "{{ (root_src.stdout | regex_search('mapper/([^-/]+)-', '\\1')) | default('') }}"

    - name: Ensure needed tools exist
      package:
        name:
          - lvm2
          - util-linux
        state: present

  tasks:
    - name: Read fstab lines for /data* mounts
      shell: "awk '$1 !~ /^#/ && $2 ~ /{{ data_mount_regex }}/ {print $0}' /etc/fstab || true"
      register: fstab_data
      changed_when: false

    - name: Parse fstab entries -> [device, mountpoint]
      set_fact:
        data_entries: >-
          {{
            (fstab_data.stdout_lines | default([]))
            | map('regex_replace','\\s+',' ')
            | map('split',' ')
            | list
          }}
        data_devices: "{{ data_entries | map('first') | list | unique }}"
        data_mountpoints: "{{ data_entries | map('nth',1) | list | unique }}"

    - name: Resolve UUID=/LABEL= to block devices
      shell: |
        dev="$1"
        if echo "$dev" | grep -Eq '^(UUID|LABEL)='; then
          blkid -o device -t "$dev" || true
        else
          echo "$dev"
        fi
      args: { stdin: "" }
      loop: "{{ data_devices }}"
      loop_control: { loop_var: devspec }
      register: resolved
      changed_when: false

    - name: Discover LVs/VGs for those devices
      shell: |
        lvdisplay -C --noheadings -o vg_name,lv_name,lv_path 2>/dev/null | awk '{print $1","$2","$3}'
      register: all_lvs
      changed_when: false

    - name: Filter LV paths that match resolved devices
      set_fact:
        resolved_devs: "{{ (resolved.results | map(attribute='stdout') | list) | unique }}"
        lv_triplets: >-
          {{
            (all_lvs.stdout | default('')).split('\n')
            | select('match','^.+,.+,.+$')
            | list
          }}
    - name: Build LV/VG target sets (exclude root VG)
      set_fact:
        lvs_to_touch: >-
          {{
            lv_triplets
            | map('split',',')
            | selectattr('2','in', resolved_devs)
            | map('nth',2)
            | list
            | unique
          }}
        vgs_to_touch: >-
          {{
            lv_triplets
            | map('split',',')
            | selectattr('2','in', resolved_devs)
            | map('nth',0)
            | list
            | unique
            | difference([root_vg])
          }}

    - name: Collect PVs under those VGs
      shell: |
        for vg in {{ (vgs_to_touch|default([])) | join(' ') }}; do
          pvs --noheadings -o pv_name,vg_name 2>/dev/null | awk -v V="$vg" '$2==V{print $1}'
        done
      register: pvs_info
      when: (vgs_to_touch | length) > 0
      changed_when: false

    - name: Compose report (dry run if WIPE != WIPE)
      copy:
        dest: "{{ report_path }}"
        mode: '0600'
        content: |
          ===============================================
          DATA VG CLEANUP REPORT ({{ 'DRY RUN' if WIPE != 'WIPE' else 'EXECUTION' }})
          Host           : {{ inventory_hostname }}
          Submitter      : {{ submitting_user }}
          Email          : {{ submitter_email }}
          Date           : {{ '%Y-%m-%d %H:%M:%S' | strftime }}
          Root VG        : {{ root_vg | default('N/A') }}
          -----------------------------------------------
          /etc/fstab data mounts : {{ data_mountpoints | join(', ') if data_mountpoints|length>0 else 'None' }}
          Devices (fstab)        : {{ data_devices | join(', ') if data_devices|length>0 else 'None' }}
          LV paths               : {{ lvs_to_touch | join(', ') if lvs_to_touch|length>0 else 'None' }}
          VGs (target)           : {{ vgs_to_touch | join(', ') if vgs_to_touch|length>0 else 'None' }}
          PVs (target)           : {{ pvs_info.stdout_lines | join(', ') if (pvs_info.stdout_lines is defined) else 'None' }}
          -----------------------------------------------
          ACTION: {{ 'DRY RUN ONLY (select WIPE to execute).' if WIPE != 'WIPE' else 'WIPING as requested (WIPE=WIPE).' }}
          SAFETY: Root VG is never touched.
          ===============================================

    - name: Email report
      shell: |
        if command -v mail >/dev/null 2>&1; then
          mail -s "[{{ inventory_hostname }}] Data VG cleanup {{ 'DRY RUN' if WIPE != 'WIPE' else 'EXECUTION' }}" "{{ submitter_email }}" < "{{ report_path }}"
        else
          echo "mail(1) not available; report left at {{ report_path }}"
        fi
      changed_when: false

    - name: Stop if DRY RUN
      meta: end_play
      when: WIPE != 'WIPE'

    # ================= EXECUTION (WIPE) =================
    - name: Backup /etc/fstab
      copy:
        src: /etc/fstab
        dest: "/etc/fstab.bak.{{ lookup('pipe','date +%Y%m%d%H%M%S') }}"
        remote_src: true
        mode: '0600'

    - name: Unmount data mountpoints (best effort)
      shell: |
        mp="$1"
        if mountpoint -q "$mp"; then umount -fl "$mp" || umount -f "$mp" || true; fi
      loop: "{{ data_mountpoints }}"
      loop_control: { loop_var: mp }
      changed_when: false

    - name: Remove matching fstab lines for /data mounts
      lineinfile:
        path: /etc/fstab
        state: absent
        regexp: '^[^#].*\\s{{ data_mount_regex }}\\s'

    - name: Remove LVs behind data mounts
      shell: |
        lvpath="$1"
        [ -e "$lvpath" ] && lvremove -fy "$lvpath" || true
      loop: "{{ lvs_to_touch }}"
      loop_control: { loop_var: lvpath }
      changed_when: false

    - name: Remove empty VGs (excluding root VG)
      shell: |
        vg="$1"
        if [ "$(lvs --noheadings -o lv_name "$vg" 2>/dev/null | wc -w)" -eq 0 ]; then
          vgremove -fy "$vg" || true
        fi
      loop: "{{ vgs_to_touch }}"
      loop_control: { loop_var: vg }
      changed_when: false

    - name: Wipe LVM/filesystem signatures on PVs
      shell: |
        dev="$1"
        [ -b "$dev" ] && wipefs -a "$dev" || true
      loop: "{{ (pvs_info.stdout_lines | default([])) | unique }}"
      loop_control: { loop_var: dev }
      changed_when: false

    - name: Append execution summary to report
      shell: |
        {
          echo "";
          echo "EXECUTION COMPLETE: Data volumes wiped. Root VG untouched.";
        } >> "{{ report_path }}"
      changed_when: false

    - name: Email completion report
      shell: |
        if command -v mail >/dev/null 2>&1; then
          mail -s "[{{ inventory_hostname }}] Data VG cleanup EXECUTION COMPLETE" "{{ submitter_email }}" < "{{ report_path }}"
        else
          echo "mail(1) not available; report left at {{ report_path }}"
        fi
      changed_when: false


=======
{
  "file": "cti_rhel_eapbigdata_bdeng_vm_maintenance_ozone_datavg_cleanup.yml",
  "action": "EAP Ozone Data VG cleanup",
  "params": [
    {
      "display-name": "Cleanup Mode (REPORT=Dry-run, WIPE=Execute)",
      "param-name": "WIPE",
      "default-value": "REPORT",
      "allowed-values": ["REPORT", "WIPE"],
      "validation": true,
      "required": true,
      "hidden": false,
      "field-type": "DROPDOWN"
    }
  ]
}
